/*
 * generated by Xtext
 */
package de.nordakademie.ticket.ui.quickfix

import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import de.nordakademie.ticket.validation.TicketValidator
import de.nordakademie.ticket.ticket.Workflow
import java.util.List
import java.util.ArrayList
import de.nordakademie.ticket.ticket.Field
import de.nordakademie.ticket.ticket.Role
import de.nordakademie.ticket.ticket.ModelIssue
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.common.util.TreeIterator
import de.nordakademie.ticket.ticket.Person
import de.nordakademie.ticket.ticket.IssueType
import de.nordakademie.ticket.ticket.IssueScreen

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#quick-fixes
 */
class TicketQuickfixProvider extends org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider {


@Fix(TicketValidator.EMPTY_STRING)
def fillDescription(Issue issue, IssueResolutionAcceptor acceptor){
	var String emptyElement = issue.data.get(0)
	acceptor.accept(issue, 
		'Fill ' + emptyElement, 
		"Fill " + emptyElement +" of '" + issue.data.get(1) + "' with '" + issue.data.get(2) + "'" , 
		'',
		[
			element, 
			context | 
				(element as Field).description = issue.data.get(2);
		]
	)
}


@Fix(TicketValidator.EMPTY_ROLE)
def setOpenIssue(Issue issue, IssueResolutionAcceptor acceptor){
	acceptor.accept(issue, 
		'Allow to create new Issue', 
		"Allow to create new Issue for Role '" + issue.data.get(0) + "'" , 
		'',
		[
			element, 
			context | 
				(element as Role).openIssue = true
		]
	)
}


@Fix(TicketValidator.EMPTY_ROLE)
def addTransitionToRole(Issue issue, IssueResolutionAcceptor acceptor){
	acceptor.accept(issue, 
		'Add Transition', 
		"Add Transition to Role '" + issue.data.get(0) + "'" , 
		'',
		[
			element, 
			context | 
				(element as Role).transitions.add(
					(element.eContainer as ModelIssue).transition.get(0)
				)
		]
	)
}


@Fix(TicketValidator.ELEMENT_CONTAINS_LIST_WITH_DUPLICATES)
def removeTransition(Issue issue, IssueResolutionAcceptor acceptor){
	acceptor.accept(issue, 
		'Remove all duplicates', 
		"Remove all duplicated '" + issue.data.get(1) + "' from '" + issue.data.get(0) +"'", 
		'',
		[
			element, 
			context |
				if (element instanceof Workflow) {
					(element as Workflow).transitions.removeAllDuplicates();
				} else if (element instanceof Role) {
					(element as Role).transitions.removeAllDuplicates();
				} else if (element instanceof Person) {
					(element as Person).roles.removeAllDuplicates();
				} else if (element instanceof IssueType) {
					(element as IssueType).fields.removeAllDuplicates();
				} else if (element instanceof IssueScreen) {
					(element as IssueScreen).fields.removeAllDuplicates();
				} 
					
		]
	)
}



def removeAllDuplicates (List<?> list){
	var List<Object> checkList = new ArrayList<Object>
	var int i;
	var Object element;

	for (i = list.size - 1;  i >= 0;  i--) {
		element = list.get(i);
		if (checkList.contains(element)){
			list.remove(i)
		} else {	
			checkList.add(element)
		}
	}
}




//@Fix(TicketValidator.EMPTY_WORKFLOW)
//def addTransition(Issue issue, IssueResolutionAcceptor acceptor){
//	acceptor.accept(Issue issue, 'Add Transition', 'Add Transition', '')[
//		context |
//		
//	]
//}


//	@Fix(MyDslValidator::INVALID_NAME)
//	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
//			context |
//			val xtextDocument = context.xtextDocument
//			val firstLetter = xtextDocument.get(issue.offset, 1)
//			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
//		]
//	}
}
